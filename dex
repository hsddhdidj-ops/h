-- fake executor env

local RunService = game.RunService
local boost = {"getscriptclosure", "hookfunction", "debug.getconstant", "debug.getproto", "debug.getupvalue", "debug.getupvalues", "debug.setconstant", "debug.setstack", "debug.setupvalue", "getcallbackvalue", "sethiddenproperty", "getrawmetatable", "hookmetamethod", "getnamecallmethod", "setrawmetatable", "setreadonly", "syn", "io", "filesystem", "writefile", "readfile", "appendfile", "listfiles", "makefolder", "isfile", "isfolder", "delfile", "delfolder", "dofile", "loadfile", "isreadonly", "identifyexecutor", "getgc", "getloadedmodules", "getrenv", "getrunningscripts", "getscripthash", "getscripts", "getsenv", "getthreadidentity", "setthreadidentity", "getscriptbytecode", "setscriptable", "isscriptable", "debug.getstack", "debug.getinfo", "debug.getconstants", "newcclosure", "isexecutorclosure", "islclosure", "iscclosure", "getcallingscript", "clonefunction", "checkcaller", "compareinstances", "cloneref", "drawing.new", "drawing.fonts", "isrenderobj", "getrenderproperty", "setrenderproperty", "cleardrawcache", "geninstances", "getinstances", "getui", "gethiddenproperty", "isrbxactive", "getconnections", "fireclickdetector", "crypt.hash", "crypt.generatekey", "crypt.generatebytes", "crypt.decrypt", "crypt.encrypt", "crypt.base64decode", "crypt.base64encode", "cache.replace", "cache.iscached", "cache.invalidate", "setfpscap", "debug.getprotos", "dofile", "setclipboard", "setrbxclipboard", "queue_on_teleport", "drawing", "drawing.new", "drawing.fonts", "messagebox", "lz4compress", "lz4decompress", "getnilinstances", "cache.replace", "cache.iscached", "cache.invalidate", "crypt.hash", "crypt.generatekey", "crypt.generatebytes", "crypt.decrypt", "crypt.encrypt", "crypt.base64decode", "crypt.base64encode", "mousescroll", "mousemoverel", "mousemoveabs", "mouse2release", "mouse2press", "mouse2click", "mouse1release", "mouse1press", "mouse1click"}

getgenv = getgenv or shared.getgenv or function(...)
	return getfenv() or _G
end

local preserved = {"getgenv"}
local genv = getgenv() 

for i, v in pairs(genv) do 
	if table.find(boost, i) then 
		genv[i] = nil 
	end 
end 

for i, v in pairs(genv) do
	if not table.find(preserved, i) and type(v) ~= "function" then 
		genv[i] = nil 
	end
end 

-- fake identity
local exploit_identity, exploit_capabilities = 8, 0xFFFFFF;

getgenv().httpGet = function(url)
	local success, result = pcall(function()
		game.HttpService:RequestAsync({
			Url = url,
			Method = "GET",
			Headers = {
				["Content-Type"] = "application/text"
			}
		})

	end);
	if success then
		return result
	end
	return {}
end

getgenv().gethui = function()
	return owner.PlayerGui;
end

getgenv().getthreadidentity = function()  -- theres another way to do it via message logging?? but this is better
	return exploit_identity
end

getgenv().getidentity = function(...)
	return exploit_identity
end

getgenv().getthreadcontext = function() 
	return exploit_identity 
end

getgenv().etthreadidentity = function(identity) -- this isnt really possible in luau at all, you can spoof printidentity to make it work as 'fake' so it returns "Current identity is %s", only for looks, but in reality it would be thread 3 and there are tons of scripts to debunk your fake printidentity
	return exploit_identity 
end

getgenv().setidentity = function(identity)
	return exploit_identity
end

getgenv().setthreadcontext = function(identity)
	return exploit_identity 
end

-- input library

getgenv().mouse1click = function(x, y)
	local vim = game:GetService('VirtualInputManager') -- this will simulate input events 
	x = x or 0
	y = y or 0
	vim:SendMouseButtonEvent(x, y, 0, true, game, false)
	task.wait()
	vim:SendMouseButtonEvent(x, y, 0, false, game, false)
end

function mouse2click(x, y)
	local vim = game:GetService('VirtualInputManager')
	x = x or 0
	y = y or 0
	vim:SendMouseButtonEvent(x, y, 1, true, game, false)
	task.wait()
	vim:SendMouseButtonEvent(x, y, 1, false, game, false)
end

getgenv().mouse1press = function(x, y)
	local vim = game:GetService('VirtualInputManager')
	x = x or 0
	y = y or 0
	vim:SendMouseButtonEvent(x, y, 0, true, game, false)
end

function mouse1release(x, y)
	local vim = game:GetService('VirtualInputManager')
	x = x or 0
	y = y or 0
	vim:SendMouseButtonEvent(x, y, 0, false, game, false)
end

function mouse2press(x, y)
	local vim = game:GetService('VirtualInputManager')
	x = x or 0
	y = y or 0
	vim:SendMouseButtonEvent(x, y, 1, true, game, false)
end

function mouse2release(x, y)
	local vim = game:GetService('VirtualInputManager')
	x = x or 0
	y = y or 0
	vim:SendMouseButtonEvent(x, y, 1, false, game, false)
end

function mousescroll(x, y, a)
	local vim = game:GetService('VirtualInputManager')
	x = x or 0
	y = y or 0
	a = a and true or false
	vim:SendMouseWheelEvent(x, y, a, game)
end

function mousemoverel(relx, rely)
	local vim = game:GetService('VirtualInputManager')
	local Pos = workspace.CurrentCamera.ViewportSize
	relx = relx or 0
	rely = rely or 0
	local x = Pos.X * relx
	local y = Pos.Y * rely
	vim:SendMouseMoveEvent(x, y, game)
end

function mousemoveabs(x, y)
	local vim = game:GetService('VirtualInputManager')
	x = x or 0
	y = y or 0
	vim:SendMouseMoveEvent(x, y, game)
end

local fpscap = math.huge
getgenv().setfpscap = function(cap)
	cap = tonumber(cap)
	assert(type(cap) == "number", "invalid argument #1 to 'setfpscap' (number expected, got " .. type(cap) .. ")", 2)
	if cap < 1 then cap = math.huge end
	fpscap = cap
end
local clock = tick()
if RunService:IsClient() then
	RunService.RenderStepped:Connect(function()
		while clock + 1 / fpscap > tick() do end
		clock = tick()

		task.wait()
	end)
end;

getgenv().getfpscap = function()
	return fpscap
end

print("meow :3")

print(getfpscap())
